//! ## Optional fields
//!
//! * `label` override widget label.
//! * `catch`
//! * `map` Applies a mapping function to `&mut Self` (works the same as in the
//!   [input example](../input/index.html#mapping))
//!
//! ## Example
//!
//! ```
//! #[derive(imgui_ext::Gui)]
//! struct Comboboxes {
//!     // All parameters are optional.
//!     #[imgui(combobox)]
//!     turbo: bool,
//!
//!     // Optionally, you can override the label:
//!     #[imgui(combobox(label = "Combobox!"))]
//!     check: bool,
//! }
//! ```
//!
//! ### Result
//!
//! ![][result]
//!
//! [result]: 
use imgui::{ImStr, Ui};

/// Structure generated by the annoration.
pub struct ComboboxParams<'a> {
    pub label: &'a ImStr,
    pub selected: usize,
}

/// Trait for types that can be represented with a combobox.
pub trait Combobox {
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool;
}

impl<C: Combobox> Combobox for Option<C> {
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        if let Some(ref mut elem) = elem {
            C::build(ui, elem, params)
        } else {
            false
        }
    }
}

impl<S: AsRef<ImStr>> Combobox for [S; 3] { // TODO: Other array sizes
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        let items = elem.iter().collect::<Vec<_>>(); // TODO: Avoid alloc
        let mut current_item = params.selected; // TODO: Handle mutability
        imgui::ComboBox::new(params.label).build_simple_string(ui, &mut current_item, &items)
    }
}

impl<T: Combobox> Combobox for Box<T> {
    #[inline]
    fn build(ui: &Ui, elem: &mut Self, params: ComboboxParams) -> bool {
        T::build(ui, elem, params)
    }
}
